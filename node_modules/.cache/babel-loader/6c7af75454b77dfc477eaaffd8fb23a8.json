{"ast":null,"code":"var _jsxFileName = \"/Users/bradleylopez/Development/personalProjects/BradShowpage/frontend/showpage-client/src/Grid.js\",\n    _s = $RefreshSig$();\n\nimport React, { useState, useCallback, useMemo } from \"react\";\nimport PropTypes from \"prop-types\";\nimport Lightbox from \"./Lightbox\";\nimport \"./Grid.css\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nimport { Fragment as _Fragment } from \"react/jsx-dev-runtime\";\n\nconst Grid = ({\n  images,\n  rowHeight,\n  margin = 0,\n  width\n}) => {\n  _s();\n\n  const [showLightbox, setShowLightbox] = useState(false);\n  const [selectedIndex, setSelectedIndex] = useState();\n\n  const handleImageClick = e => {\n    setSelectedIndex(e.target.getAttribute(\"data-index\"));\n    setShowLightbox(true);\n  }; // Creates <img/> tags from image and row metadata.\n  //\n\n\n  const imageDataToImgTag = useCallback((image, totalIndex, rowIndex, row, imageWidth) => {\n    const calculatedRowHeight = width / imageWidth; // Calculate the dimensions and margin of each image. This needs\n    // to be inline since we need some values from the JS.\n\n    let imageStyle = {\n      height: calculatedRowHeight + \"px\",\n      // Take back out the margin from the ratio.\n      width: calculatedRowHeight * image[1] - margin + \"px\",\n      // Don't add margin to the last item in a row\n      marginRight: rowIndex === row.length - 1 ? 0 : margin + \"px\"\n    };\n    return /*#__PURE__*/_jsxDEV(\"img\", {\n      className: \"grid-img\",\n      style: imageStyle,\n      \"data-index\": totalIndex,\n      onClick: handleImageClick,\n      src: image[0].src,\n      alt: image[0].alt\n    }, \"img_\" + image[0].id + \"_\" + image[1], false, {\n      fileName: _jsxFileName,\n      lineNumber: 33,\n      columnNumber: 9\n    }, this);\n  }, [margin, width]); // Build the rows of the grid. Each row must have an aspect ratio of at least minAspectRatio.\n  // Then, each image in the row is scaled up to fill the desired width of the row, while maintaining\n  // the aspect ratio of each photo in the row.\n\n  const rows = useMemo(() => {\n    let allRows = [];\n    let row = [];\n    let widthSoFar = 0; // We'll use this value to calculate how many pictures we need in a row.\n    // The \"min\" aspect ratio is the aspect ratio that will allow the row to\n    // span the correct length while being between minRowHeight and maxRowHeight\n\n    const minAspectRatio = width / rowHeight;\n\n    for (let i = 0; i < images.length; i++) {\n      let image = images[i]; // Add the margin into the ratio.\n\n      let ratio = image.width / image.height; // If we're less than the min aspectRatio then keep adding more items to the row.\n\n      if (widthSoFar <= minAspectRatio && i !== images.length - 1) {\n        // Add the ratio contributed by the margin.\n        ratio += margin / image.height;\n        row.push([image, ratio]);\n        widthSoFar += ratio;\n      } else {\n        if (i === images.length - 1) {\n          row.push([image, ratio]);\n          widthSoFar += ratio;\n        }\n\n        let imageElements = [];\n\n        for (let j = 0; j < row.length; j++) {\n          imageElements.push(imageDataToImgTag(row[j], i - row.length + j, j, row, widthSoFar));\n        } // Add the finished row to the list of all rows.\n\n\n        allRows.push(imageElements); // Start a new row with the current image as the first image\n\n        row = [[image, ratio]];\n        widthSoFar = ratio;\n      }\n    } // This style also needs to be inline since we use the padding prop.\n    // (Would be nice to use something like styled-components for this instead)\n\n\n    const divStyle = {\n      display: \"flex\",\n      marginBottom: margin + \"px\"\n    };\n    return allRows.map((row, index) => /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"grid-row\",\n      style: divStyle,\n      children: row\n    }, \"row_\" + index, false, {\n      fileName: _jsxFileName,\n      lineNumber: 99,\n      columnNumber: 7\n    }, this));\n  }, [width, imageDataToImgTag, images, margin, rowHeight]);\n  const handleClose = useCallback(() => {\n    setShowLightbox(false);\n  }, []);\n  const handlePrev = useCallback(() => {\n    setSelectedIndex(selectedIndex => (+selectedIndex - 1 + images.length) % images.length);\n  }, [images.length]);\n  const handleNext = useCallback(() => {\n    setSelectedIndex(selectedIndex => (+selectedIndex + 1) % images.length);\n  }, [images.length]);\n  return /*#__PURE__*/_jsxDEV(_Fragment, {\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"grid-container\",\n      children: rows\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 121,\n      columnNumber: 7\n    }, this), showLightbox ? /*#__PURE__*/_jsxDEV(Lightbox, {\n      selectedImage: images[selectedIndex],\n      onClose: handleClose,\n      onPrev: handlePrev,\n      onNext: handleNext\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 123,\n      columnNumber: 9\n    }, this) : null]\n  }, void 0, true);\n};\n\n_s(Grid, \"JKbk1imZ09zdMiMEQ3LLMdbF9oA=\");\n\n_c = Grid;\nGrid.propTypes = {\n  images: PropTypes.arrayOf(PropTypes.shape({\n    src: PropTypes.string.isRequired,\n    height: PropTypes.number.isRequired,\n    width: PropTypes.number.isRequired\n  })).isRequired,\n  rowHeight: PropTypes.number.isRequired,\n  margin: PropTypes.number\n};\nexport default Grid;\n\nvar _c;\n\n$RefreshReg$(_c, \"Grid\");","map":{"version":3,"sources":["/Users/bradleylopez/Development/personalProjects/BradShowpage/frontend/showpage-client/src/Grid.js"],"names":["React","useState","useCallback","useMemo","PropTypes","Lightbox","Grid","images","rowHeight","margin","width","showLightbox","setShowLightbox","selectedIndex","setSelectedIndex","handleImageClick","e","target","getAttribute","imageDataToImgTag","image","totalIndex","rowIndex","row","imageWidth","calculatedRowHeight","imageStyle","height","marginRight","length","src","alt","id","rows","allRows","widthSoFar","minAspectRatio","i","ratio","push","imageElements","j","divStyle","display","marginBottom","map","index","handleClose","handlePrev","handleNext","propTypes","arrayOf","shape","string","isRequired","number"],"mappings":"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","sourcesContent":["import React, { useState, useCallback, useMemo } from \"react\";\nimport PropTypes from \"prop-types\";\nimport Lightbox from \"./Lightbox\";\nimport \"./Grid.css\";\n\nconst Grid = ({ images, rowHeight, margin = 0, width }) => {\n  const [showLightbox, setShowLightbox] = useState(false);\n  const [selectedIndex, setSelectedIndex] = useState();\n\n  const handleImageClick = e => {\n    setSelectedIndex(e.target.getAttribute(\"data-index\"));\n    setShowLightbox(true);\n  };\n\n  // Creates <img/> tags from image and row metadata.\n  //\n  const imageDataToImgTag = useCallback(\n    (image, totalIndex, rowIndex, row, imageWidth) => {\n      const calculatedRowHeight = width / imageWidth;\n\n      // Calculate the dimensions and margin of each image. This needs\n      // to be inline since we need some values from the JS.\n      let imageStyle = {\n        height: calculatedRowHeight + \"px\",\n\n        // Take back out the margin from the ratio.\n        width: calculatedRowHeight * image[1] - margin + \"px\",\n\n        // Don't add margin to the last item in a row\n        marginRight: rowIndex === row.length - 1 ? 0 : margin + \"px\"\n      };\n      return (\n        <img\n          className=\"grid-img\"\n          style={imageStyle}\n          data-index={totalIndex}\n          onClick={handleImageClick}\n          src={image[0].src}\n          alt={image[0].alt}\n          key={\"img_\" + image[0].id + \"_\" + image[1]}\n        />\n      );\n    },\n    [margin, width]\n  );\n\n  // Build the rows of the grid. Each row must have an aspect ratio of at least minAspectRatio.\n  // Then, each image in the row is scaled up to fill the desired width of the row, while maintaining\n  // the aspect ratio of each photo in the row.\n  const rows = useMemo(() => {\n    let allRows = [];\n    let row = [];\n    let widthSoFar = 0;\n\n    // We'll use this value to calculate how many pictures we need in a row.\n    // The \"min\" aspect ratio is the aspect ratio that will allow the row to\n    // span the correct length while being between minRowHeight and maxRowHeight\n    const minAspectRatio = width / rowHeight;\n\n    for (let i = 0; i < images.length; i++) {\n      let image = images[i];\n\n      // Add the margin into the ratio.\n      let ratio = image.width / image.height;\n\n      // If we're less than the min aspectRatio then keep adding more items to the row.\n      if (widthSoFar <= minAspectRatio && i !== images.length - 1) {\n        // Add the ratio contributed by the margin.\n        ratio += margin / image.height;\n        row.push([image, ratio]);\n        widthSoFar += ratio;\n      } else {\n        if (i === images.length - 1) {\n          row.push([image, ratio]);\n          widthSoFar += ratio;\n        }\n        let imageElements = [];\n        for (let j = 0; j < row.length; j++) {\n          imageElements.push(\n            imageDataToImgTag(row[j], i - row.length + j, j, row, widthSoFar)\n          );\n        }\n        // Add the finished row to the list of all rows.\n        allRows.push(imageElements);\n\n        // Start a new row with the current image as the first image\n        row = [[image, ratio]];\n        widthSoFar = ratio;\n      }\n    }\n\n    // This style also needs to be inline since we use the padding prop.\n    // (Would be nice to use something like styled-components for this instead)\n    const divStyle = {\n      display: \"flex\",\n      marginBottom: margin + \"px\"\n    };\n    return allRows.map((row, index) => (\n      <div className=\"grid-row\" style={divStyle} key={\"row_\" + index}>\n        {row}\n      </div>\n    ));\n  }, [width, imageDataToImgTag, images, margin, rowHeight]);\n\n  const handleClose = useCallback(() => {\n    setShowLightbox(false);\n  }, []);\n\n  const handlePrev = useCallback(() => {\n    setSelectedIndex(\n      selectedIndex => (+selectedIndex - 1 + images.length) % images.length\n    );\n  }, [images.length]);\n\n  const handleNext = useCallback(() => {\n    setSelectedIndex(selectedIndex => (+selectedIndex + 1) % images.length);\n  }, [images.length]);\n\n  return (\n    <>\n      <div className=\"grid-container\">{rows}</div>\n      {showLightbox ? (\n        <Lightbox\n          selectedImage={images[selectedIndex]}\n          onClose={handleClose}\n          onPrev={handlePrev}\n          onNext={handleNext}\n        />\n      ) : null}\n    </>\n  );\n};\n\nGrid.propTypes = {\n  images: PropTypes.arrayOf(\n    PropTypes.shape({\n      src: PropTypes.string.isRequired,\n      height: PropTypes.number.isRequired,\n      width: PropTypes.number.isRequired\n    })\n  ).isRequired,\n  rowHeight: PropTypes.number.isRequired,\n  margin: PropTypes.number\n};\n\nexport default Grid;\n"]},"metadata":{},"sourceType":"module"}